'use strict';

var fs$1 = require('fs');
var path = require('path');
var fs = require('fs-extra');
var prettier = require('prettier');
var sveld = require('sveld');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var fs__namespace$1 = /*#__PURE__*/_interopNamespace(fs$1);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var prettier__namespace = /*#__PURE__*/_interopNamespace(prettier);
var sveld__default = /*#__PURE__*/_interopDefaultLegacy(sveld);

class WriterMarkdown {
    onAppend;
    source = "";
    hasToC = false;
    toc = [];

    constructor(options) {
        this.options={ parser: "markdown", printWidth: 80 };
        this.options = {...this.options,onAppend:options.onAppend};
        this.onAppend = options.onAppend;
    }

    format(raw ) {
        try {
            return prettier__namespace.format(raw, this.options);
        } catch (error) {
            process.stderr.write(error + "\n");
            return raw;
        }
    }

    async write(filePath, raw) {
        try {
            await fs__namespace.ensureFile(filePath);
            await fs__namespace.writeFile(filePath, this.format(raw));
        } catch (error) {
            process.stderr.write(error + "\n");
        }
    }

    appendLineBreaks() {
        this.source += "\n\n";
        return this;
    }

    append(type, raw) {
        switch (type) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
                const length = Number(type.slice(-1));
                this.source += `${Array.from({ length })
                    .map((_) => "#")
                    .join("")} ${raw}`;

                if (this.hasToC && type === "h2") {
                    this.toc.push({
                        array: Array.from({ length: (length - 1) * 2 }),
                        raw,
                    });
                }
                break;
            case "quote":
                this.source += `> ${raw}`;
                break;
            case "p":
                this.source += raw;
                break;
            case "divider":
                this.source += "---";
                break;
            case "raw":
                this.source += raw;
                break;
        }

        if (type !== "raw") this.appendLineBreaks();
        //this.onAppend.call(this, type, this);
        return this;
    }

    tableOfContents() {
        this.source += "<!-- __TOC__ -->";
        this.hasToC = true;
        this.appendLineBreaks();
        return this;
    }

    end() {
        this.source = this.source.replace(
            "<!-- __TOC__ -->",
            this.toc
                .map(({ array, raw }) => {
                    return `${array.join(" ")} - [${raw}](#${raw.toLowerCase().replace(/\`/g, "").replace(/\s+/g, "-")})`;
                })
                .join("\n")
        );

        return this.source;
    }
}

//import { formatTsProps, getTypeDefs } from "./writer-definitions";

const PROP_TABLE_HEADER = `| Prop name | Kind | Reactive | Type | Default value | Description |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n`;
const SLOT_TABLE_HEADER = `| Slot name | Default | Props | Fallback |\n| :--- | :--- | :--- | :--- |\n`;
const EVENT_TABLE_HEADER = `| Event name | Type | Detail |\n| :--- | :--- | :--- |\n`;
const MD_TYPE_UNDEFINED = "--";

function formatPropType(type) {
    if (type === undefined) return MD_TYPE_UNDEFINED;
    type = type.replace(/[\n]/gm, " ");
    type = type.replace(/[\r]/gm, " ");
    return `<code>${type.replace(/\|/g, "&#124;")}</code>`;
}

function escapeHtml(text) {
    return text.replace(/\</g, "&lt;").replace(/\>/g, "&gt;");
}

function formatPropValue(prop) {
    let value = prop.value;
    if (value === undefined) return MD_TYPE_UNDEFINED;
    if (prop.kind == 'function') return `<code></code>`;
    value = value.replace(/[\n]/gm, " ");
    value = value.replace(/[\r]/gm, " ");
    return `<code>${value.replace(/`/g, "\\`").replace(/\|/g, "&#124;")}</code>`;
}

function formatPropDescription(description) {
    if (description === undefined || description.trim().length === 0) return MD_TYPE_UNDEFINED;
    return escapeHtml(description).replace(/\n/g, "<br />");
}

function formatSlotProps(props) {
    if (props === undefined || props === "{}") return MD_TYPE_UNDEFINED;
    return formatPropType(props.replace(/\n/g, " "));
}

function formatSlotFallback(fallback) {
    if (fallback === undefined) return MD_TYPE_UNDEFINED;
    return formatPropType(escapeHtml(fallback).replace(/\s/g, " "));
}

function formatEventDetail(detail) {
    if (detail === undefined) return MD_TYPE_UNDEFINED;
    return formatPropType(detail.replace(/\n/g, " "));
}

function getTypeDefs(def) {
    if (def.typedefs.length === 0) return "";
    return def.typedefs.map((typedef) => `export ${typedef.ts}`).join("\n\n");
}

function getEventsFromDoc(componentDoc){
    let allevents = [];
    componentDoc.forEach((el)=>{
        el.tags.forEach((el1)=>{
            if(el1.tag=='event'){
                el.name = el1.name;
                el.detail = el.description;
                el.type='dispatched';
                allevents.push(el);
            }
        });
    });
    return allevents;
}


function writeMarkdown(components,componentDoc, options) {
    path__namespace.join(process.cwd(), options.outFile);
    const document = new WriterMarkdown({
        onAppend: (type, document) => {
            options.onAppend.call(null, type, document, components);
        },
    });
    const component = components.components[0];

    if (component.typedefs.length > 0) {
        document.append("h3", "Types").append(
            "raw",
            `\`\`\`ts\n${getTypeDefs({
                typedefs: component.typedefs,
            })}\n\`\`\`\n\n`
        );
    }

    document.append("h3", "Props");
    if (component.props.length > 0) {
        document.append("raw", PROP_TABLE_HEADER);
        [...component.props]
            .sort((a) => {
                if (a.reactive) return -1;
                if (a.constant) return 1;
                return 0;
            })
            .forEach((prop) => {
                document.append(
                    "raw",
                    `| ${prop.name} | ${`<code>${prop.kind}</code>`} | ${prop.reactive ? "Yes" : "No"} | ${formatPropType(
                        prop.type
                    )} | ${formatPropValue(prop)} | ${formatPropDescription(prop.description)} |\n`
                );
            });
    } else {
        document.append("p", "None.");
    }

    document.append("h3", "Slots");
    if (component.slots.length > 0) {
        document.append("raw", SLOT_TABLE_HEADER);
        component.slots.forEach((slot) => {
            document.append(
                "raw",
                `| ${slot.default ? MD_TYPE_UNDEFINED : slot.name} | ${slot.default ? "Yes" : "No"} | ${formatSlotProps(
                    slot.slot_props
                )} | ${formatSlotFallback(slot.fallback)} |\n`
            );
        });
    } else {
        document.append("p", "None.");
    }


    let eventsfromdoc = getEventsFromDoc(componentDoc);
    document.append("h3", "Events");

    if ( eventsfromdoc.length > 0) {
        document.append("raw", EVENT_TABLE_HEADER);
        eventsfromdoc.forEach((event) => {
            document.append(
                "raw",
                `| ${event.name} | ${event.type} | ${
                    event.type === "dispatched" ? formatEventDetail(event.detail) : MD_TYPE_UNDEFINED
                } |\n`
            );
        });



    } else {
        document.append("p", "None.");
    }


    return document.source;
}

const {parse} = require('comment-parser');

const jsonfilename = "COMPONENT_API.json";
const mdfilename = "README.md";
const packagejsonfile = "package.json";


function mdDocumentation() {
    let sv = sveld__default["default"]({markdown: true, json: true});
    if (!process.env.MAKE_DOC){
        return [];
    } else {
    return [
        sv,
        {
            name: 'md-documentation', // this name will show up in warnings and errors
            buildEnd(source) {
                let jsonres = loadJsonFile(jsonfilename);
                if (!jsonres) return;
                let packagejson = loadJsonFile(packagejsonfile);
                let outputapifilename = packagejson.name.replace("@fds-components/", "");
                let mdres = loadMdFile();
                let componentEntry = getComponentEntry(packagejson);
                let componentDoc;
                //componentDoc = jsonres.components[0].jsdoc;
                componentDoc = parse(componentEntry);
                let appendmd = writeMarkdown(jsonres, componentDoc, {outFile: mdfilename});
                let resstring = addResult(mdres, appendmd);
                saveMdFile(resstring);
                saveJsonFile(jsonres, componentDoc, outputapifilename);
                console.log("module is working!!!", resstring);
                return null; // other ids should be handled as usually
            },
        }];
    }
    function addResult(mdres, jsonres) {
        const regex = /(\[\/\/\]: # \"Autogeneratedstart\")([\s\S]+)(\[\/\/\]: # \"Autogeneratedstop\")/mg;
        mdres = mdres.replace(regex, "$1" + "\n" + jsonres + "\n" + "$3");
        return mdres;
    }

    function loadJsonFile(name) {
        const datafile = path__namespace.join(process.cwd(), name);
        if (fs__namespace$1.existsSync(datafile)) {
            const parsed = JSON.parse(fs__namespace$1.readFileSync(datafile, "utf-8"));
            return parsed;
        }
        return false;
    }

    function loadMdFile() {
        const datafile = path__namespace.join(process.cwd(), mdfilename);
        if (fs__namespace$1.existsSync(datafile)) {
            const parsed = fs__namespace$1.readFileSync(datafile, "utf-8");
            return parsed;
        }
    }

    function saveMdFile(data) {
        const datafile = path__namespace.join(process.cwd(), mdfilename);
        if (fs__namespace$1.existsSync(datafile)) {
            fs__namespace$1.writeFileSync(datafile, data, "utf-8");
        }
    }

    function saveJsonFile(data, componentEntry, outputapifilename) {
        if (componentEntry) {
            data = data.components[0];
            data.jsdoc = componentEntry;
            data.componentname = outputapifilename;
        }
        outputapifilename = "api-" + outputapifilename + ".json";
        const datafile = path__namespace.join(process.cwd(), outputapifilename);
        //if (fs.existsSync(datafile)) {
        fs__namespace$1.writeFileSync(datafile, JSON.stringify(data, null, 2), "utf-8");
        //}
    }


    function getComponentEntry(packagejson) {
        if (packagejson.componentFile === undefined || !packagejson.componentFile) {
            packagejson = {componentFile: 'src/App.svelte'};
        }
        const datafile = path__namespace.join(process.cwd(), packagejson.componentFile);
        if (fs__namespace$1.existsSync(datafile)) {
            const parsed = fs__namespace$1.readFileSync(datafile, "utf-8");
            return parsed;
        } else {
            process.stdout.write("Could not load component file.\n", datafile);
        }

        process.stdout.write("Could not determine an entrypoint.\n");
        process.stdout.write('Specify an entrypoint to your Svelte code in the "svelte" field of your package.json.\n');
        return null;

    }

}

//mdDocumentation()[0].buildEnd()

module.exports = mdDocumentation;
//# sourceMappingURL=index.js.map
