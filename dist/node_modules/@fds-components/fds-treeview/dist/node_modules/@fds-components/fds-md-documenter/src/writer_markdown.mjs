import * as path from "path";
import WriterMarkdown from "./WriteMarkdown.mjs";
//import { formatTsProps, getTypeDefs } from "./writer-definitions";

const PROP_TABLE_HEADER = `| Prop name | Kind | Reactive | Type | Default value | Description |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n`;
const SLOT_TABLE_HEADER = `| Slot name | Default | Props | Fallback |\n| :--- | :--- | :--- | :--- |\n`;
const EVENT_TABLE_HEADER = `| Event name | Type | Detail |\n| :--- | :--- | :--- |\n`;
const MD_TYPE_UNDEFINED = "--";

function formatPropType(type) {
    if (type === undefined) return MD_TYPE_UNDEFINED;
    type = type.replace(/[\n]/gm, " ");
    type = type.replace(/[\r]/gm, " ");
    return `<code>${type.replace(/\|/g, "&#124;")}</code>`;
}

function escapeHtml(text) {
    return text.replace(/\</g, "&lt;").replace(/\>/g, "&gt;");
}

function formatPropValue(prop) {
    let value = prop.value;
    if (value === undefined) return MD_TYPE_UNDEFINED;
    if (prop.kind == 'function') return `<code></code>`;
    value = value.replace(/[\n]/gm, " ");
    value = value.replace(/[\r]/gm, " ");
    return `<code>${value.replace(/`/g, "\\`").replace(/\|/g, "&#124;")}</code>`;
}

function formatPropDescription(description) {
    if (description === undefined || description.trim().length === 0) return MD_TYPE_UNDEFINED;
    return escapeHtml(description).replace(/\n/g, "<br />");
}

function formatSlotProps(props) {
    if (props === undefined || props === "{}") return MD_TYPE_UNDEFINED;
    return formatPropType(props.replace(/\n/g, " "));
}

function formatSlotFallback(fallback) {
    if (fallback === undefined) return MD_TYPE_UNDEFINED;
    return formatPropType(escapeHtml(fallback).replace(/\s/g, " "));
}

function formatEventDetail(detail) {
    if (detail === undefined) return MD_TYPE_UNDEFINED;
    return formatPropType(detail.replace(/\n/g, " "));
}

function getTypeDefs(def) {
    if (def.typedefs.length === 0) return "";
    return def.typedefs.map((typedef) => `export ${typedef.ts}`).join("\n\n");
}

function getEventsFromDoc(componentDoc){
    let allevents = [];
    componentDoc.forEach((el)=>{
        el.tags.forEach((el1)=>{
            if(el1.tag=='event'){
                el.name = el1.name;
                el.detail = el.description;
                el.type='dispatched';
                allevents.push(el);
            }
        });
    });
    return allevents;
}


export default function writeMarkdown(components,componentDoc, options) {
    const output_path = path.join(process.cwd(), options.outFile);
    const document = new WriterMarkdown({
        onAppend: (type, document) => {
            options.onAppend.call(null, type, document, components);
        },
    });
    const component = components.components[0];

    if (component.typedefs.length > 0) {
        document.append("h3", "Types").append(
            "raw",
            `\`\`\`ts\n${getTypeDefs({
                typedefs: component.typedefs,
            })}\n\`\`\`\n\n`
        );
    }

    document.append("h3", "Props");
    if (component.props.length > 0) {
        document.append("raw", PROP_TABLE_HEADER);
        [...component.props]
            .sort((a) => {
                if (a.reactive) return -1;
                if (a.constant) return 1;
                return 0;
            })
            .forEach((prop) => {
                document.append(
                    "raw",
                    `| ${prop.name} | ${`<code>${prop.kind}</code>`} | ${prop.reactive ? "Yes" : "No"} | ${formatPropType(
                        prop.type
                    )} | ${formatPropValue(prop)} | ${formatPropDescription(prop.description)} |\n`
                );
            });
    } else {
        document.append("p", "None.");
    }

    document.append("h3", "Slots");
    if (component.slots.length > 0) {
        document.append("raw", SLOT_TABLE_HEADER);
        component.slots.forEach((slot) => {
            document.append(
                "raw",
                `| ${slot.default ? MD_TYPE_UNDEFINED : slot.name} | ${slot.default ? "Yes" : "No"} | ${formatSlotProps(
                    slot.slot_props
                )} | ${formatSlotFallback(slot.fallback)} |\n`
            );
        });
    } else {
        document.append("p", "None.");
    }


    let eventsfromdoc = getEventsFromDoc(componentDoc);
    document.append("h3", "Events");

    if (false && component.events.length > 0 ) {
        document.append("raw", EVENT_TABLE_HEADER);

        component.events && component.events.forEach((event) => {
            document.append(
                "raw",
                `| ${event.name} | ${event.type} | ${
                    event.type === "dispatched" ? formatEventDetail(event.detail) : MD_TYPE_UNDEFINED
                } |\n`
            );
        });

        component.events && component.events.forEach((event) => {
            document.append(
                "raw",
                `| ${event.name} | ${event.type} | ${
                    event.type === "dispatched" ? formatEventDetail(event.detail) : MD_TYPE_UNDEFINED
                } |\n`
            );
        });

    } else if ( eventsfromdoc.length > 0) {
        document.append("raw", EVENT_TABLE_HEADER);
        eventsfromdoc.forEach((event) => {
            document.append(
                "raw",
                `| ${event.name} | ${event.type} | ${
                    event.type === "dispatched" ? formatEventDetail(event.detail) : MD_TYPE_UNDEFINED
                } |\n`
            );
        });



    } else {
        document.append("p", "None.");
    }


    return document.source;
    process.stdout.write(`created "${options.outFile}".\n`);
}

